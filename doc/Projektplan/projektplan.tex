\documentclass[a4paper]{article}
\usepackage[margin=3cm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage{cmbright}
\usepackage{hyperref}
\usepackage{booktabs}
\usepackage[ngerman]{babel}
\usepackage{parskip}
\usepackage{graphicx}
\usepackage{minted}
\usepackage{pdflscape}
\usepackage{array}
\usepackage{tabulary}
\usepackage{multicol}

% Page breaks between sections
\let\oldsection\section
\renewcommand\section{\clearpage\oldsection}

% JIRA/Confluence shortcuts
\def\jiraurl{https://jira.keltec.ch/jira}
\def\confluenceurl{https://jira.keltec.ch/wiki}
\newcommand{\jiraissue}[1]{\href{\jiraurl/projects/EPJ/issues/EPJ-#1}{EPJ-#1}}
\newcommand{\fulljiraissue}[1]{EPJ-#1 (\url{\jiraurl/projects/EPJ/issues/EPJ-#1})}

% Tools
\newcommand{\tool}[2]{\emph{#1\footnote{\url{#2}}}}

\begin{document}
\title{
  Projekt: kitovu \\
  \Large{Projektplan} \\[3em]
  \includegraphics[width=20em]{../../img/logo/kitovu.jpg}
}
\author{
  Florian Bruhin \\ \url{florian.bruhin@hsr.ch} \and
  Méline Sieber \\ \url{meline.sieber@hsr.ch} \and
  Nicolas Ganz \\ \url{nicolas.ganz@hsr.ch} \and
  Marco Zollinger\footnote{Eine definitive Antwort der Schulleitung steht
    weiterhin aus. Momentan ist aber damit zu rechnen, dass Marco Zollinger
    leider nicht am EPJ teilnehmen kann.} \\ \url{marco.zollinger@hsr.ch}}
\date{\today}

\maketitle

FIXME Meline Marco rausnehmen, in Titelseite nur Fussnote ändern

\section*{Änderungsgeschichte}

\begin{tabulary}{\linewidth}{llLl}
\toprule
Datum & Version & Änderung & AutorIn \\
\midrule
24.02.2018 & 1.1 & Struktur von Template übernommen, Projektantrag-Daten eingefügt, grobe Roadmap anhand der EPJ-Anleitung erstellt & Méline Sieber \\
26.02.2018 & 1.2 & Migration nach \LaTeX{}, diverse Vervollständigungen & Florian Bruhin \\
28.02.2018 & 1.3 & Weitere Ergänzungen und Komplettierung & alle drei \\
02.03.2018 & 1.4 & Lektorat und Abgabe & Méline Sieber \\
\bottomrule
\end{tabulary}
\pagebreak

\section{Einführung}
\subsection{Zweck}
Der Projektplan zu \emph{kitovu} gibt eine Vogelperspektive zum Engineering-Projekt. Er steckt den Rahmen ab, innerhalb dessen \emph{kitovu} realisiert wird. Dieses Dokument umfasst eine Projektübersicht, beschreibt, wie das Projekt organisiert ist, welche Phasen es durchläuft und wie die Besprechungen mit dem Betreuer organisiert sind. Zudem bespricht dieser Projektplan mögliche Risiken, umreisst die anstehenden Arbeitspakete und listet die wichtigen Punkte, um eine entsprechende Qualität des Codes, der Dokumentation und des Projekt-Managements zu garantieren.

\subsection{Gültigkeitsbereich}
Der vorliegende Projektplan ist für das Engineering Projekt im Frühlingssemester 2018 gültig. Falls dem Projekt grössere Veränderungen widerfahren, wird der Projektplan dementsprechend angepasst. Umfassende Änderungen werden zu Beginn des Dokumentes protokolliert.

\subsection{Referenzen}

% <Liste aller verwendeten und referenzierten Dokumente, Bücher, Links, usw.>
% <Referenz auf ein Glossar Dokument, wo alle Abkürzungen und unklaren Begriffe erklärt werden>
% <Die Quellen / Referenzen sollten mit dem Word Tool automatisch erstellt werden>

\begin{tabulary}{\linewidth}{ll}
  AppVeyor & \url{https://www.appveyor.com/} \\
  attrs & \url{http://www.attrs.org/} \\ 
  click & \url{http://click.pocoo.org/} \\ 
  coala & \url{https://coala.io/} \\
  Coding-Guideline: PEP 8 & \url{https://www.python.org/dev/peps/pep-0008/} \\
  Confluence & \url{\confluenceurl} \\
  coverage.py & \url{https://coverage.readthedocs.io/} \\
  flake8 & \url{http://flake8.pycqa.org/} \\
  Github-Repository von \emph{kitovu} & \url{https://github.com/kitovu-bot/kitovu} \\
  gitmate & \url{https://gitmate.io/} \\
  hypothesis & \url{http://hypothesis.works/} \\
  JIRA	& \url{\jiraurl} \\
  keyring & \url{https://pypi.python.org/pypi/keyring} \\ 
  mypy & \url{http://mypy-lang.org/} \\
  OpenHSR Connect & \url{https://github.com/openhsr/connect} \\
  pluggy & \url{https://pluggy.readthedocs.io/} \\ 
  pylint & \url{https://pylint.org/} \\
  PyQt5 & \url{https://www.riverbankcomputing.com/software/pyqt/intro} \\ 
  PySMB & \url{https://miketeo.net/wp/index.php/projects/pysmb} \\ 
  pytest-bdd & \url{https://github.com/pytest-dev/pytest-bdd/} \\
  pytest-qt & \url{https://pytest-qt.readthedocs.io/} \\
  pytype & \url{https://github.com/google/pytype} \\ 
  Qt & \url{http://qt.io/} \\ 
  Sphinx & \url{http://www.sphinx-doc.org/} \\
  TOML & \url{https://github.com/toml-lang/toml} \\ 
  Travis CI & \url{https://travis-ci.com/} \\
  yapf & \url{https://github.com/google/yapf} \\
\end{tabulary}

\section{Projekt-Übersicht}
% <Kurze Beschreibung des Projektes>
Kitovu ist ein Software-Client für Studentinnen und Studenten der HSR, mit dem sie von verschiedenen Quellen Unterrichtsmaterialien lokal auf den eigenen Rechner synchronisieren können.

\subsection{Zweck und Ziel von kitovu}
% <Sinn und Zweck des Projektes, sowie Zielsetzung und auch persönliche Ziele>
An der HSR müssen sich die Studentinnen und Studenten bislang ihre Unterrichtsmaterialien vom Skripteserver, von Moodle und anderen Orten von Hand zusammensuchen. Das ist aufwändig und unübersichtlich. Es existiert zwar bereits ein Synchronisationstool, \tool{OpenHSR Connect}{https://github.com/openhsr/connect}. Es stellt die Inspiration für unser Projekt dar, hat aber zahlreiche Unzulänglichkeiten: Dieser Client besitzt kein GUI, der Code ist weder strukturiert noch einheitlich, er ist plattformabhängig und funktioniert nur für den HSR-Skripteserver.

\emph{Kitovu} soll das ändern: ein Client, der von verschiedenen Plattformen ausgewählte Unterrichtsmaterialien auf den eigenen Rechner synchronisiert, plattformunabhängig und erweiterbar für verschiedene Plattformen, nicht nur den Skripteserver. Zielgruppe sind primär Studierende, sekundär Dozierende der HSR. Der Client könnte potentiell an anderen Hochschulen eingesetzt werden.

Kitovu bindet primär den Skripteserver ein. Der Terminal-basierte Client funktioniert mittels Profilen zu unterschiedlichen Plattformen (Moodle, Skripteserver, Studentenportal). Pro Profil sind Verbindungsdaten und eventuelle Login-Credentials im Client hinterlegt. Die Daten-Synchronisation erfolgt immer nur von Server zu Client, erfolgreiche und misslungene Datentransfers werden protokolliert. Ein rudimentäres GUI dient als Proof-of-Concept.

Pro Profil lässt sich Folgendes definieren:

\begin{itemize}
  \item welche Ordner/Dateien synchronisiert werden sollen.
  \item welche Ordner/Dateien von der Synchronisation ausgeschlossen werden sollen.
  \item wie mit Duplikaten/lokal bestehenden Dateien umgegangen werden soll.
\end{itemize}

Kitovu ist ausbaubar und damit modular: Zusätzlich zu den beiden Plattformen (Skripteserver, Moodle/Studentenportal) können in zukünftigen Projekten beliebig viele Plattformen als separates Plugin bzw. Profil realisiert werden.

Optionale Features:

\begin{itemize}
  \item Moodle und/oder das Studentenportal. Die Implementation von Moodle oder dem Studentenportal ist abhängig von den weiter unten beschriebenen Risiken.
  \item Komplettes GUI, das der Funktionalität des Terminalprogramms entspricht.
\end{itemize}

\subsubsection{Persönliche Ziele}
\begin{description}
\item[Nicolas Ganz]
  Mein Ziel ist es, mehr Erfahrung zu sammeln, was das Management und die Organisation eines solchen Projekts anbelangt.
  Zusätzlich möchte ich Erfahrungen mit Python und dessen Tools und Libraries sammeln.
\item[Florian Bruhin] Erfahrungen sammeln bei der ''Leitung'' eines kleinen
  Software-Teams, einige neue nützliche Tools ausprobieren, und das Endprodukt
  selbst: Endlich alle HSR-Dokumente zu einem Modul problemlos an einem Ort!
\item[Méline Sieber] Verbessern der Python-Programmierfähigkeiten und -kenntnisse (nur Grundkenntnisse vorhanden); allererstes Softwareprojekt durchziehen und entsprechende Arbeitsschritte und Werkzeuge kennenlernen; Erfahrung im Test-Driven-Development sammeln; 
\item[Marco Zollinger] Schritt von Python als Skriptsprache hin zur Verwendung in einem Softwareprojekt mit professionellem Workflow und Tools; Erfahrungen sammeln über Softwareentwicklung mit mehreren Personen und der dazugehörigen Arbeitsteilung und Kommunikation; Beitrag leisten in einem Open Source-Projekt das hoffentlich auch anderen Studenten zugute kommt; Kenntnisse in GUI-Entwicklung mit PyQt5 verbessern.

\end{description}

\subsection{Lieferumfang}
% <Konkreten Lieferumfang des Projektes beschreiben>

\begin{multicols}{2}
  \begin{description}
    \item[Produkt:] \strut \\[-1em]
    \begin{itemize}
      \item Anforderungsspezifikation
      \item Domainanalyse
      \item Entwurfsbeschreibung: Software-Architektur
      \item Installationsanleitung
      \item Screenshots des Clients (GUI und Terminal)
      \item Testspezifikation und Testprotokoll
      \item Sourcecode
      \item Folien der Schlusspräsentation
    \end{itemize}
    \item[Produktmanagement:] \strut \\[-1em]
    \begin{itemize}
      \item Projektplan
      \item Zeiterfassung
      \item Zeitauswertung
      \item Codestatistik
      \item Soll-/Ist-Vergleich
      \item Persönlicher Bericht zu den im Projekt gesammelten Erfahrungen
      \item Erklärung zur eigenständigen Durchführung der Arbeit
    \end{itemize}
  \end{description}
\end{multicols}

\subsection{Annahmen und Einschränkungen}
% <Annahmen die für diesen Projektplan getroffen werden und Einschränkungen denen er unterliegt>
Wir berücksichtigen keine HSR-externen Anbieter wie etwa Dropbox, OneDrive, GoogleDrive.

Support für macOS ist keine Priorität, auch wenn wenn die Infrastruktur dafür
grundsätzlich existiert und dies durch Python kein Problem darstellen sollte.
Wir werden die Tests initial auf macOS laufen lassen, sollte es da aber zu
Problemen kommen, werden wir die Tests auf macOS ausschalten.

\section{Projektorganisation}
% <Kurze Beschreibung der Projektstruktur>
Die Hierarchie in unserem Team ist flach.
Grössere Entscheidungen werden immer im Plenum besprochen und festgelegt.
Da sämtliche Teammitglieder einen anderen Hintergrund haben und unterschiedlich viel Erfahrung mitbringen profitieren wir bei diesen Diskusionsrunden von unterschiedlichen Blickwinkeln.

Die Betreung des Projektes wird von Herrn Daniel Keller übernommen.

\subsection{Organisationsstruktur}
% <Projektmitglieder nennen und deren Aufgaben und Verantwortungen aufzählen>
\begin{description}

\item[Florian Bruhin] \strut \\[-1em]
  \begin{itemize}
    \item Product Owner: Er hat den Gesamtüberblick über die Ziele und priorisiert die einzelnen Tasks.
    \item QA Supervisor: Er prüft die Test-Coverage, die Test-Qualität und das Linting. Soweit möglich erkennt er Bad-Practices, wie dupliziertem Code oder konzeptionelle Unschönheiten.
    \item UI-Programmierung
  \end{itemize}
\item[Nicolas Ganz] \strut \\[-1em]
  \begin{itemize}
    \item Scrum Master: Er coached das Scrum-Teams, unteranderem mit dem sicherstellen, dass Scrum eingehalten wird und dem Vorbereiten und Leiten der Scrum-Sitzungen.
    \item JIRA/Confluence System-Administrator
    \item Zeitbuchungs-Überwacher: Er hat den Überblick von dem erledigten Aufwand, noch offenen Aufwand und der verbleibender Zeit
    \item Code-Writer
  \end{itemize}
%\item[Marco Zollinger] \strut \\[-1em]
%  \begin{itemize}
%  \end{itemize}
\item[Méline Sieber] \strut \\[-1em]
  \begin{itemize}
    \item Lektorin: Sie liest die Dokemente gegen und korrigiert diese wo nötig.
    \item Verantwortlich für Code- und User-Dokumentation mit Sphinx.
    \item Protokolliererin: Sie erstellt Protokolle zu sämtlichen Sitzungen.
    \item Kommunikation nach aussen
    \item Code-Writer
  \end{itemize}
\end{description}

\subsection{Externe Schnittstellen}

% <Ansprechpartner, verantwortliche Personen, Betreuer, usw. aufzählen>

\begin{itemize}
  \item Daniel Keller (\url{daniel.keller@hsr.ch}) als unser Betreuer für das Engineering-Projekt.
  \item Frank Koch (\url{frank.koch@hsr.ch}) als verantwortliche Person für das HSR-Moodle.
  \item Raphael Zimmermann (\url{raphael.zimmermann@hsr.ch}) als Hauptentwickler
    von \emph{OpenHSR Connect}, welches die
    Inspiration für unser Projekt darstellt, aber nur den Skripteserver
    unterstützt.
  \item Externe Tester: Für Usability- und Beta-Tests wollen wir verschiedene
    HSR-Studierende kontaktieren, ggf. auch mit einem Aufruf via e-Mail. Da das
    Tool von jedem HSR-Studierenden nutzbar sein soll, sollte es kein Problem
    darstellen, dafür kurzfristig Probanden zu finden.
\end{itemize}

Frank Koch und Raphael Zimmermann wurden bereits über unser Projekt informiert
und unterstützen unser Vorhaben gerne.

\section{Management-Abläufe}
\subsection{Kostenvoranschlag}
% <Wie viel Zeit steht zur Verfügung? In welcher Zeitspanne läuft das Projekt? Wird das Projekt früher beendet, dafür wöchentlich mehr gearbeitet?>

Da es sich bei dem EPJ um ein Modul mit 4 ECTS mit vollem Aufwand im Semester handelt, ist mit einem Richtwert von 120 Stunden pro Person zu rechnen.
Mit der Annahme, dass Marco Zollinger leider nicht im Projekt dabei sein wird,
fällt also ein totaler Aufwand von $3 \cdot 120 = 360$ Stunden an.

Wir wollen die vollen 15 Wochen für das Projekt ausnutzen, womit wöchentlich
durchschnittlich pro Person ein Arbeitsaufwand von $120 / 15 = 8$ Stunden zu
leisten ist.


\subsection{Zeitliche Planung}
% <Kurze Beschreibung der zeitlichen Planung und mit einer Grafik einen Überblick über die Phasen, Iterationen und Meilensteine geben. Das Datum des Eintreffens der Meilensteine sollte in der Phasenübersicht ersichtlich sein.>

Wir nutzen das in der Vorlesung empfohlene ``Scrum plus end of
elaboration''-Modell, wobei wir eine zusätzliche Training-Iteration hinzufügen
(siehe unten). Eine Iteration soll dabei eine Woche dauern.

\begin{tabulary}{\linewidth}{lllll}
\toprule
KW & Sem.-Woche & Meilenstein / Tätigkeit & Review & Phase \\
\midrule
8  & 1 & \textbf{M0: Projektantrag} & & \\
\hline
9  & 2 & \textbf{M1: Projektplan} & & 1 \\
10 & 3 & \textbf{M2: Requirements} & Review Projektplan & \\
11 & 4 & Training (Python, Tools, etc.) & Review Requirements & \\
12 & 5 & Architekturprototyp erstellen & \emph{Daniel Keller abwesend}& \\
13 & 6 & \textbf{M3: End of Elaboration} & & \\
\hline
14 & 7 & & Review End of Elaboration & 2 \\
15 & 8 & & & \\
16 & 9 & & & \\
17 & 10 & \textbf{M4: Architektur} & & \\
\hline
18 & 11 & \textbf{M5: Usability-Test} & Review Architektur & 3 \\
19 & 12 & & & \\
20 & 13 & \textbf{M6: Feature-Freeze} & Review Qualität & \\
21 & 14 & & & \\
22 & 15 & \textbf{M7: Projektabschluss} & Schluss-Präsentation & \\
\bottomrule
\end{tabulary}

% Folgende Reviews müssen enthalten sein:
% 1. Review Projektplan mit Zeitplan und aktuellen Iterationsplänen – Termin: SW03
% 2. Review der Anforderungsspezifikation und der Domainanalyse – Termin: frei wählbar
% (empfohlen: vor End of Elaboration)
% 3. Ende Elaboration (s. Checkliste) mit Architekturprototyp – Termin: wählbar SW05-08
% 4. Review von Architektur/Design und Architekturdoku – Termin: wählbar bis SW14*)
% 5. Q-Review: Code-Qualität (u.a. Metriken), Tests und weitere Q-Massnahmen – Termin:
% wählbar nach End of Elaboration bis SW14*)
% 6. Schlusspräsentation und Demo der Software: SW15 (genaues Datum wird bekanntgegeben)

\subsubsection{Phasen / Iterationen}

Die einzelnen Iterationen werden wir mit der Scrum Methode agil planen.
Auch wenn die Iteration länger als eine Woche dauert, werden wir ein wöchentliches Sprint Planning Meeting durchführen.
Dadurch können wir den Stand der Arbeiten analysieren und im Problemfall zeitnahe reagieren.

\paragraph{Phase 1: Elaboration} \strut \\[-1em]

Die \emph{Elaboration} Phase dauert 5 Wochen und umfasst das Erstellen des Projektplanes, das Zusammentragen sämtlicher Requirements und das Erstellen eines Architekturprototypes.

Da Méline, Nicolas und Marco noch Python-Anfänger sind und es auch eines der
Ziele ist, im Engineering-Projekt Erfahrung zu sammeln, haben wir in der Elaboration-Phase
eine Woche Zeit für Training eingeplant. Darin wird Florian den anderen Team-Mitgliedern eine
Einführung in die Themen und Technologien geben, die beim Projekt benutzt
werden.

Danach sollten die Mitglieder das Wissen soweit möglich autodidaktisch erwerben,
wobei Florian gerne beratend zur Seite steht.

\subparagraph{Iterationen} \strut \\[-1em]

\begin{tabulary}{\linewidth}{lLlL}
  \toprule
  Nr & Beschreibung & Dauer & End-Resultat \\
  \midrule
  1-1 & Projektplan erstellen & 1 Woche & M1: Projektplan \\
  1-2 & Requirements erstellen & 1 Woche & M2: Requirements \\
  1-3 & Training & 1 Woche & Grundverständnis von Python für sämtliche Teammitglieder erarbeiten \\
  1-4 & Architekturprototyp erstellen & 1 Woche & Ein lauffähiger Architekturprototyp \\
  1-5 & End of Elaboration & 1 Woche & Sämtliche Dokumente und zu präsentierendes Material für die Review \\
  \bottomrule
\end{tabulary}

\paragraph{Phase 2: Construction} \strut \\[-1em]

Die \emph{Construction} Phase dauert 4 Wochen und wir werde uns der hauptsächlichen Entwicklungsarbeit widmen.
Da an den Aufgaben parallel gearbeitet wird können wir dies nicht in detaillierte Iterationen packen.

Diese Phase ist am schwierigsten zu planen und die Iterationen können öfters geändert werden.

\subparagraph{Iterationen} \strut \\[-1em]

\begin{tabulary}{\linewidth}{lLlL}
  \toprule
  Nr & Beschreibung & Dauer & End-Resultat \\
  \midrule
  2-1 & Volle Synchronisierung mit dem Skripteserver & 3 Wochen & Getestete Grundfunktionalitäten der \emph{kitovu} Applikation \\
  2-2 & Optionale Features einbauen & 1 Woche & M4: Architektur \\
  \bottomrule
\end{tabulary}

\paragraph{Phase 3: Transition} \strut \\[-1em]

Die \emph{Transition} Phase dauert 5 Wochen.
Wir konzentrieren uns auf Testing, Dokumentation und die Behebung von Bugs. Falls die Usability-Tests zeigen, dass noch grundlegende Änderungen nachgeführt werden müssen, findet dies ebenfalls statt.

\subparagraph{Iterationen} \strut \\[-1em]

\begin{tabulary}{\linewidth}{lLlL}
  \toprule
  Nr & Beschreibung & Dauer & End-Resultat \\
  \midrule
  3-1 & Usability-Tests durchführen & 1 Woche & M5: Usability-Tests \\
  3-2 & Letzte Features und Verbesserungen & 1 Woche & M6: Feature Freeze \\
  3-3 & Projektabschluss & 2 Wochen & Sämtliche Dokumente und Abgabematerialien \\
  \bottomrule
\end{tabulary}

\subsubsection{Meilensteine}

Wir haben das Projekt in 8 Meilensteine eingeteilt, welche wir im JIRA über Epics abgebildet haben und sämtliche weiteren Tickets gruppiert.

\paragraph{M0: Projektantrag} \fulljiraissue{5}

Ziel dieses Meilenstein ist es, die Grundidee für das Projekt zu eruieren und einen Projektantrag dazu zu erstellen.

\paragraph{M1: Projektplan} \fulljiraissue{6}

Dieser Meilenstein befasst sich mit dem Zusammentragen aller Eckpunkte für das Projekt und das Erstellen dieses Projektplanes.

\paragraph{M2: Requirements} \fulljiraissue{7}

% <Setzen Sie in Ihrem Projekt 6-8 Meilensteine. Kurze Beschreibung der Meilensteine mit genauem Datum. In der Regel auf Ende jeder Iteration einen Meilenstein setzen (diese Faustregel gilt nur für die SE-2Projekte, in realen Projekten haben Sie oft deutlich mehr Iterationen als Meilensteine, weil Meilensteine dort die nach aussen kommunizierten Ereignisse sind). Schreiben Sie zu jedem Meilenstein auf, welche Arbeitsprodukte (work products) Sie dann abliefern werden . Spezifizieren Sie wenn nötig auch den Fertigstellungsgrad der Arbeitsprodukte, z.B. „Zentrale Use Cases ‚fully dressed‘, restliche UCs im ‚brief‘ Format“, oder „Architekturskizze inkl. Definition der Interfaces zwischen Sub-Systemen und Deployment Diagramm“>

In diesem Meilenstein sollten die folgenden Abgaben getätigt werden:

\begin{itemize}
  \item Use Cases
  \item Personas (evtl.)
  \item Domain Modell
  \item nicht-funktionale Anforderungen
  \item GUI-Design
\end{itemize}

\paragraph{M3: End of Elaboration} \fulljiraissue{8}

Mit diesem Meilenstein werden wir das Training durch führen und einen Architekturprototypen erstellen.
Damit können die meisten Unklarheiten geklärt werden.
Falls es grössere Probleme gibt können wir einen Strategie-/Architekurwechsel angehen, ohne all zu grosse Umstellung an dem Code vornehmen zu müssen.

\paragraph{M4: Architektur} \fulljiraissue{9}

Am Ende dieses Meilensteines werden wir die Grundsätzlichen Funktionalitäten für die Applikation haben.
Diese ist bereits mit Unit- und Integration-Tests gründlich getestet und von unserer Seite lauffähig.

Nach diesem Meilenstein ist die erste Alpha-Version bereit um getestet zu werden.

\paragraph{M5: Usability-Test} \fulljiraissue{10}

In diesem Meilensten werden wir die Tests von aussenstehenden Personen durchführen.

Da wir bereits im Meilenstein M4 gründliche Tests eingebaut haben geht es hier nur noch um die Test-Protokolle für die aussenstehenden Personen und dessen Auswertung.

\paragraph{M6: Feature Freeze} \fulljiraissue{11}

In diesem Meilenstein werden Probleme und Verbesserungen, welche aus dem Meilenstein M5 hervorgekommen sind angegangen.

Nach diesem Meilenstein werden keine Features mehr eingebaut, sondern nur noch Bugfixes.

\paragraph{M7: Projektabschluss} \fulljiraissue{12}

Das Ziel dieses Meilensteins ist es sämtliche Dokumente für den Projektabschluss fertiggestellt werden und die Präsentation vorbereitet wird.

\subsection{Besprechungen}
% <regelmässige Besprechungen nennen (wann, wo, wer, Ziel und/oder Grund)>
\begin{itemize}
\item Gesamt-Teamsitzung: Dienstag und Mittwoch ab 17 Uhr, Mittwoch von 12-13 Uhr. Koordination, Klärung von Fragen, Besprechung des weiteren Verlaufs.
\item Gemeinsame Arbeit, nach Bedarf: Méline Sieber und Nicolas Ganz, Mittwoch von 10-13 Uhr.
\item Gemeinsame Arbeit, nach Bedarf: Florian Bruhin, Méline Sieber und ggf. Marco Zollinger, Freitag ab 15 Uhr (in KW 9, 11, 14, 16, 18, 20, 22).
\item Arbeit am Projekt: Florian Bruhin und ggf. Marco Zollinger, Montag-Nachmittag ab 13 Uhr.
\end{itemize}

\section{Risikomanagement}
FIXME Florian Tabellendarstellung/Text zu Risiken
\newgeometry{margin=1cm}
\begin{landscape}
  \subsection{Risiken}
  
  \thispagestyle{empty}
  
  \begin{tabulary}{\linewidth}{lLLlLLLL}
    \toprule
    Nr & Titel & Beschreibung & \parbox[t]{5em}{max. \\ Schaden [h]} & \parbox[t]{8em}{Eintritts-\\wahrschein-\\lichkeit} & \parbox[t]{9em}{Gewichteter \\ Schaden} & Vorbeugung & Verhalten beim Eintreten \\
    \midrule
    R1 & Ausfall CI & Travis CI oder AppVeyor (externe Services) fallen aus & 1 & 0.1\% & 0.001 & keine & Ausschalten von ``protected branches'', Nutzung von Alternativen (Circle CI) \\ \hline
    R2 & Ausfall GitHub & GitHub fällt aus & 5 & 0.01\% & 0.0005 & Lokale Kopien des Codes & Migration auf anderen Service \\ \hline
    R3 & Ausfall Keltec & Ausfall des keltec.ch Servers, auf dem JIRA/Confluence liegen & 5 & 0.018\% & 0.0009 & Replizierung auf mehreren physischen Servern, Backups & Migration auf neuen Server, schlimmstenfalls Neueinrichtung \\ \hline
    R4 & Moodle-Integration nicht umsetzbar & FIXME & 8 & 40\% & 3.2 & Moodle ist optional & Feature weglassen \\ \hline
    R5 & Studentenportal-Integration nicht umsetzbar & FIXME & 8 & 30\% & 2.4 & Studentenportal ist optional & Feature weglassen oder ggf. APIs zu Studentenportal hinzufügen \\ 
    \bottomrule
  \end{tabulary}
\end{landscape}
\restoregeometry

% <Verweis auf Dokument TechnischeRisiken.xlsx>
FIXME Florian: mehr zu Risiken schreiben

Die Moodle-Anbindung könnte nach Rücksprache mit einem der Administratoren, Frank Koch, zu Schwierigkeiten führen (Gespräch geführt am 21.2.2018). Es existiert eine WebDAV-Schnittstelle, die jedoch unter Umständen nicht für das Projekt geöffnet werden kann.

Für das Studentenportal ist der OpenHSR-Verein verantwortlich, Kontaktperson ist XXX.

\subsection{Umgang mit Risiken}
% <Begründungen zur Tabelle. Weitere Beschreibungen zu Massnahmen und Vorbeugungen. Werden Reserven /Rückstellungen eingeplant? Wieso und wie viele? Wann werden Risiken qualitätssichernd überprüft (Vorgehen und Zeitpunkt(e) zur Neubeurteilung der Risiken)?>

\section{Arbeitspakete}

Die Auflistung der Arbeitspakete sind unter folgendem Link zu finden:

FIXME Nicolas: Hier Daten zum Gastlogin einfügen

% <Definieren Sie in einem separaten Tool (Redmine oder XLS, o.a.) diejenigen Arbeitspakete, die Ihnen zu Beginn des Projektes schon mal einfallen. Zu Beginn können Pakete eher generisch ausfallen (z.B. ‚Domainmodell erstellen‘ oder ‚GUI Programmieren‘, oder ‚ Usability Testing‘).
%
%Denken Sie daran, dass es in jedem Projekt auch eine ganze Reihe von ‚overhead‘-Tätigkeiten gibt: Projektleitung und -Sitzungen, Aufsetzen der Server und Werkzeuge, Qualitätsmassnahmen, Schlusspräsentation erstellen und anderes mehr – alles Tätigkeiten, die nicht direkt zum Software-Produkt führen. Planen Sie genug Zeit auch für diese Tätigkeiten ein.
%
%Dann sollte es in jeder Projektplanung einige projektspezifische Arbeitspakete geben, wie sie so nicht in anderen Projekten vorkommen (z.B. ‚ Level-Editor entwerfen‘, oder ‚Verifikation der Zahlungsangaben programmieren‘). Wenn es keine solchen Arbeitspakete gibt, ist der Projektplan zu generisch. Das heisst auch, dass man sich zu wenig Gedanken über die anfallenden Arbeiten gemacht hat.
%
%Später im Projekt werden Sie die Arbeitspakete noch verfeinern, verschieben, jemandem zuordnen, neu schätzen, etc. Deswegen empfiehlt sich der Einsatz eines Werkzeuges wie Redmine.
%
%Dokumentieren Sie URL und Logins auf das Projektmanagement Tool, in welchem die Meilensteine und die dazugehörigen Arbeitspakete erfasst sind.>

Diese Issues sind zu finden unter \jiraurl/projects/EPJ/issues/\emph{\textless JIRA-ID\textgreater} und eine Überischt unter \url{\jiraurl/projects/EPJ/issues}.

\section{Infrastruktur}
%<Benötigte Infrastruktur aufzählen. Spezielle Geräte, Laptop , Tools usw. und nötigenfalls aufzeigen für welche Bereiche diese verwendet werden. Eventuell auch Verfahren beschreiben (auf Tools bezogen).>
\begin{itemize}
  \item JIRA-Server auf keltec.ch für Issue-Tracking und Projektmanagement
    (betrieben von Nicolas Ganz)
  \item Confluence-Server auf keltec.ch als Wiki (betrieben von Nicolas Ganz)
  \item Der Code liegt auf GitHub.
    Wir benutzen GitHub Pull Requests für Code Review, nicht aber Issues ($\rightarrow$ JIRA)
    und das Wiki ($\rightarrow$ Confluence)
  \item Wir benutzen Travis CI\footnote{\url{https://travis-ci.com/}} (Linux und
    ggf. macOS) sowie AppVeyor\footnote{\url{https://www.appveyor.com/}} als
    externe CI (continuous integration) Anbieter.
\end{itemize}

\section{Qualitätsmassnahmen}
% <Was wird unternommen damit das Produkt des Projektes, sowie dessen gesamter Verlauf eine hohe Qualität erreicht? Übersicht in einer Tabelle geben mit Massnahmen, Zeitraum und Ziel der Massnahme>
%
%Bezug zur Roadmap weiter oben.

Wir setzen zur Qualitätssicherung auf verschiedene Tools sowie Code Reviews,
welche nachfolgend genauer beschrieben werden. Diese Tools werden in der
Elaboration-Phase eingerichtet und dann über die ganze Laufzeit des Projekts
eingesetzt.

\subsection{Dokumentation}
%<Wo befinden sich die Dokumente (SVN oder Git Server) und wie wird deren Qualität sichergestellt?>

Wir unterscheiden zwischen vier Arten der Dokumentation:

\begin{itemize}
  \item Protokolle zu Treffen und Entscheidungen werden im Confluence (Wiki) protokolliert.
  \item Längere Dokumente die weitergegeben werden (wie beispielsweise dieses
    Dokument) werden mit \LaTeX{} verfasst und landen in einem
    \texttt{doc/}-Unterordner im GitHub-Repository
  \item Dokumentation für Endbenutzer wird in
    Sphinx\footnote{\url{http://www.sphinx-doc.org/}} geschrieben, welches das
    Standardwerkzeug für die Python-Community (und auch darüber hinaus, wie
    beispielsweise den Linux-Kernel) darstellt.
  \item Code-Dokumentation wird ebenfalls mit Sphinx verfasst, mit im Code
    eingebetteten Python \emph{docstrings} (ähnlich zu JavaDoc).
\end{itemize}

\subsection{Projektmanagement}
%<Welches Tool wird für Projektmanagement eingesetzt (z.B. Redmine oder Trac) und wie erfolgt dieser Einsatz? Dazugehörige Links und Logins (Gastbenutzer).>
Das Projekt verwendet JIRA und Confluence, um \emph{kitovu} zu managen, zu koordinieren und Arbeitspakete zu verteilen. Via JIRA läuft auch die Zeiterfassung.

\subsection{Entwicklung}
%<Wo befindet sich der Source Code (z.B. SVN oder Git) und wie wird dessen Qualität sichergestellt?>

Der Source-Code befindet sich auf Github im Repository \texttt{kitovu-bot/kitovu\footnote{\url{https://github.com/kitovu-bot/kitovu}}}.

Wie unter \ref{sec:codereviews} beschrieben, setzen wir auf das
Vier-Augen-Prinzip mit Code Reviews.

Ausserdem setzen wir auf diverse Tools (bekannt als
linting/metrics/formatting/static analysis) um konsistenten und möglichst
fehlerfreien Code zu garantieren. Diese werden unter \ref{sec:tools} kurz beschrieben.

\subsubsection{Vorgehen}
% <Vorgehen in der Entwicklung>
Wir benutzen ein einfaches git branching Modell mit einem \verb|master| branch
in den funktionierende Änderungen eingepflegt werden, sowie feature/hotfix
branches für alle Änderungen.

\subsubsection{Tools}
\label{sec:tools}

\paragraph{Type annotations} Mittels sogenannten \emph{type annotations} (auch
bekannt als \emph{gradual typing}) wird die Typensicherheit im Code geprüft.
Ähnlich zu Typescript erzwingt die Sprache selber keine expliziten
Typendeklarationen (dynamic typing), jedoch sind diese valide Python-Syntax und
werden einfach ignoriert. Dadurch ist kein separater ``pre-compiler'' wie bei
Typescript nötig, jedoch ein externes Tool zur Überprüfung der Typen.

Beispiel von Typenannotationen:

\begin{minted}{python}
  def calc_primes(start: int) -> List[int]:
      primes: List[int] = []
      ...
\end{minted}

Wir benutzen dazu das Tool \tool{mypy}{http://mypy-lang.org/}.
Ursprünglich im Rahmen einer Doktorarbeit an der Universität Cambridge
entwickelt hat es sich zum etablierten Werkzeug entwickelt und wird durch Firmen
wie Dropbox benutzt und weiter entwickelt.

Als Alternative dazu wollen wir uns kurz
\tool{pytype}{https://github.com/google/pytype} von Google
anschauen, wobei die Wahl vermutlich auf mypy als das bekanntere Werkzeug fallen wird.

\paragraph{pylint} Das \tool{pylint}{https://pylint.org/}-Projekt
kombiniert verschiedene Funktionalitäten in einem Werkzeug, welche die
Code-Qualität erhöhen. Es hilft bei der Einhaltung von code guidelines
(Zeilenlänge, Variablennamen, unbenutzte Imports, etc.), kann aber auch Fehler
finden und enthält verschiedene Metrics (Anzahl Klassen, Argumente, Members, etc.).

\paragraph{flake8} \tool{flake8}{http://flake8.pycqa.org/} ist
ein weiteres bekanntes Tool. Der Fokus liegt hier eher auf Style-Problemen,
flake8 macht im Gegensatz zu pylint keine tiefergehende statische Code-Analyse.
Es gibt zwar einige Überschneidungen mit pylint, trotzdem macht es Sinn, beide
Tools zu verwenden, da flake8 doch einige nützliche Checks hat, die in pylint
nicht vorhanden sind. Ausserdem ist es viel schneller und kann gut im Editor/IDE
eingebunden werden, um sofortiges Feedback zu kriegen.

\paragraph{yapf} Bei \tool{yapf}{https://github.com/google/yapf}
(Yet Another Python Formatter) von Google handelt sich um ein weiteres Tool aus
der Linting/Style-Ecke, welches Probleme auch automatisiert beheben kann. Wir
werden vermutlich primär auf pylint/flake8 setzen, aber es wäre schön, wenn wir
auch yapf testen könnten.

\paragraph{coala / GitMate} \tool{Coala}{https://coala.io/} ist
(im Zusammenspiel mit \tool{GitMate}{https://gitmate.io/}) ein
Tool, welches alle obengenannte Tools (und auch weitere, für andere Sprachen) in
einem Tool vereint. Es bietet auch die Möglichkeit, Probleme automatisch als
Kommentare für pull requests zu verfassen. Es wäre schön, wenn wir es in unseren
Workflow integrieren können, ist aber nicht zwingend notwendig.

\paragraph{Paketierung} Darüber hinaus gibt es weitere Tools welche die
korrekte Paketierung überprüfen bzw. erleichtern:
\tool{check-manifest}{https://github.com/mgedmin/check-manifest/}
sowie \tool{pyroma}{https://github.com/regebro/pyroma/}. Diese
wollen wir einsetzen, sobald dies Sinn macht - also vermutlich erst nach dem
Feature Freeze, wenn wir das Projekt für Linux/Windows/ggf. macOS pakettieren.

\subsubsection{Bibliotheken}

In diesem Abschnitt werden die im Projekt verwendeten Bibliotheken kurz
vorgestellt, inklusive einigen Codebeispielen.

\paragraph{attrs} Bei \tool{attrs}{http://www.attrs.org/} handelt es sich um eine Bibliothek, die das
erstellen von Data-Klassen stark vereinfacht. Anstatt viel ``Boilerplate-Code''
schreiben zu müssen:

\begin{minted}{python}
class File:

    def __init__(self, filename: str):
        self._filename = filename

    def __repr__(self) -> str:
        return f'{self.__class__.__name__}("{self._filename}")'

    def __hash__(self) -> int:
        return hash(self._filename)

    def __eq__(self, other) -> bool:
        if not isinstance(other, self.__class__):
            return NotImplemented
        return self._filename == other._filename

    def __lt__(self, other) -> bool:
        if not isinstance(other, self.__class__):
            return NotImplemented
        return self._filename < other._filename
\end{minted}

kann stattdessen folgender Code geschrieben werden, welcher zum selben Ergebnis führt:

\begin{minted}{python}
import attr

@attr.s
class File:

    filename: str = attr.ib()
\end{minted}

Diese Bibliothek hat sich so weit verbreitet, dass eine vergleichbare
Funktionalität in der nächsten Python-Version eingebaut werden wird\footnote{\url{https://www.python.org/dev/peps/pep-0557/}}.

\paragraph{click}

\tool{click}{http://click.pocoo.org/} erlaubt es, sehr einfach
Kommandozeilen-Interfaces zu erstellen und kümmert sich beispielsweise um die
Behandlung von Optionen/Flags:

\begin{minted}{python}
import click

@click.command()
@click.option('--profile', help="Profile to synchronize")
def sync(profile):
    """Synchronize data from a HSR server."""
    # ...
\end{minted}

Daraus wird dann ein Tool, welches man mit den definierten Optionen aufgerufen
werden kann, und welches beispielsweise auch eine Hilfe beinhaltet:

\begin{verbatim}
$ python3 test.py --help
Usage: test.py [OPTIONS]

  Synchronize data from a HSR server.

Options:
  --profile TEXT  Profile to synchronize
  --help          Show this message and exit.
\end{verbatim}

\paragraph{PyQt5}

\tool{PyQt5}{https://www.riverbankcomputing.com/software/pyqt/intro} ist ein
bekanntes GUI-Toolkit für Python, welches auf \tool{Qt}{http://qt.io/} (C++) aufsetzt.

Es ist sehr mächtig, gleichzeitig lassen sich einfache GUIs sehr schnell
realisieren:

\begin{minted}{python}
import sys
from PyQt5.QtWidgets import QApplication, QLabel

app = QApplication(sys.argv)
label = QLabel("Hello World")
label.show()
app.exec_()
\end{minted}

\paragraph{PySMB}

\tool{PySMB}{https://miketeo.net/wp/index.php/projects/pysmb} ist eine
Bibliothek, welche plattformunabhängig das Windows Filesharing Protokoll (SMB)
implementiert. Das \emph{OpenHSR Connect}-Projekt benutzt diese Bibliothek
bereits, womit wir sicher sein können, dass sie zuverlässig mit dem
HSR-Skripteserver funktioniert.

\paragraph{keyring}

Mit \tool{keyring}{https://pypi.python.org/pypi/keyring} lassen sich einfach
Passwörter sicher speichern. Aus der Dokumentation:

\begin{minted}{python}
>>> import keyring
>>> keyring.set_password("system", "username", "password")
>>> keyring.get_password("system", "username")
'password'
\end{minted}

Es nutzt dabei die Möglichkeiten der verschiedenen Betriebssysteme um Passwörter
sicher abzulegen, was einer Speicherung von Passwörtern im Klartext klar zu
bevorzugen ist.

\paragraph{Plugin-Framework}

Zum Laden von Plugins bietet sich ebenfalls eine externe Bibliothek an. Wir
wollen verschiedene Lösungen dazu noch genauer evaluieren, tendieren aber zu
\tool{pluggy}{https://pluggy.readthedocs.io/}, womit einfach eine Schnittstelle
für Plugins definiert und von Plugins implementiert werden kann:

\begin{minted}{python}
import pluggy

hookspec = pluggy.HookspecMarker("kitovu")
hookimpl = pluggy.HookimplMarker("kitovu")

class PluginSpec:

    """Specification of the plugin API."""

    @hookspec
    def login(self, server: str):
        pass


class FileserverPlugin:

    """Implementation of a plugin."""

    @hookimpl
    def login(self, server: str):
        # ...


pm = pluggy.PluginManager("kitovu")
pm.add_hookspecs(PluginSpec)

pm.register(FileserverPlugin())
pm.hook.login(server="...")
\end{minted}

\paragraph{Konfiguration}

Für das Einlesen der Konfiguration wollen wir ebenfalls eine Bibliothek
benutzen. Momentan ist noch offen, welche Bibliothek dazu genau genuzt werden
soll, wobei sich \tool{TOML}{https://github.com/toml-lang/toml} anbieten würde.

\paragraph{Moodle}

Für die Verbindung mit Moodle ist eventuell ebenfalls eine Bibliothek nötig.
Die Details sind uns hier noch nicht bekannt.

\subsubsection{Unit Testing}
% <Wo werden welche Unit Tests geschrieben um die Qualität sicherzustellen? Wie wird die Testabdeckung sichergestellt (z.B. durch EclEmma)?>

Wir benutzen \tool{pytest}{https://docs.pytest.org/} als Test
Framework. Während Python ein unittest-Framework mit einer JUnit-Ähnlichen API
eingebaut hat, vereinfacht pytest das Verfassen von Tests ungemein.

Wir nutzen ausserdem verschiedene plugins für pytest:

\begin{itemize}
\item \tool{coverage.py}{https://coverage.readthedocs.io/} für
    Test-Coverage sowie \tool{codecov.io}{https://codecov.io/}
    als online-Service (Kommentare in pull-requests bei geänderter Coverage).
\item \tool{pytest-qt}{https://pytest-qt.readthedocs.io/} für das
    automatisierte Testen der GUI
\item eventuell \tool{pytest-bdd}{https://github.com/pytest-dev/pytest-bdd/} für Behaviour-Driven-Testing (Cucumber/Gherkin)
\item eventuell \tool{hypothesis}{http://hypothesis.works/} für
  Fuzzing-Tests, wobei automatisch Test-Werte aufgrund von Typendeklarationen
  generiert werden. Es ist aber fraglich, inwieweit dies in diesem Projekt Sinn macht.
\end{itemize}

Die Tests müssen im GitHub pull-request enthalten sein. Ziel ist, dass die
Coverage bei keiner Änderung sinkt, und idealerweise am Ende des Projekts bei
über 90\% liegt.

\subsubsection{Code-Reviews}
\label{sec:codereviews}
%<Werden Code Reviews gemacht und wie werden diese gemacht?>

Nebst diversen Tools zur Qualitätssicherung (siehe unten) setzen wir auf GitHub
code reviews: Sämtlicher Code wird, bevor er in den Master-Branch des
Github-Repositories eingepflegt wird, nach dem Vier-Augen-Prinzip geprüft. Dies
nicht nur aus Qualitätsgründen, sondern auch, weil alle involvierten Personen
sehr viel aus code reviews lernen können.

Normalerweise werden die pull requests von Florian Bruhin in seiner Rolle als
technischem Projektleiter geprüft, wobei darauf geachtet wird, dass auch andere
Projektmitglieder genügend Zeit haben, den Code anzuschauen.

Für Änderungen von Florian selbst (oder falls Florian nicht reagieren sollte)
darf der Code auch von einem anderen Projektmitglied geprüft werden.

\subsubsection{Code-Style-Guidelines}
%<Welche Code Style Guidelines werden angewendet? Sie brauchen keine eigenen Guidelines zu erfinden. Am besten referenzieren Sie existierende Guidelines, mit denen Sie einverstanden sind. Evtl. noch Abweichungen dazu dokumentieren>
Wir verwenden PEP 8\footnote{\url{https://www.python.org/dev/peps/pep-0008/}}
(Python Enhancement Proposal), den offiziellen Style-Guide der Python
Foundation. Dieser wurde ursprünglich für Entwicklungen an Python selbst
konzipiert, hat sich aber als Standardwerk verbreitet und wird auch von den
Style-Checkern standardmässig verwendet.

\subsection{Testen}

\subsubsection{Unit-Tests}

Einzelne spezifische Funktionen werden wir durch Unit-Tests abgedeckt.
Ziel dieser Tests ist es, die einzelnen Funktionen sehr detailliert zu testen und damit Edge-Cases abdecken.

\subsubsection{Integration-Tests}

Um die Integration sämtlicher Komponenten zu testen, werden wir Integrations-Tests schreiben.
Diese testen nicht die Kompenenten selbst, sondern die eigentliche Anwendung des Benutzers.

Wir wollen zumindest die einzelnen Use-Cases als Integrations-Tests abbilden.
Je nach dem finden wir aber bei der genaueren Planung noch weitere Orte wo Integrations-Tests gegenüber Unit-Tests zu bevorzugen sind.

\subsubsection{Vorgehen}

Die Tests werden immer automatisch ausgeführt, wenn ein Push auf das Git-Repository gemacht wird.
Ein Merge-Request von einem Feature-Branch kann nur durchgeführt werden, falls die sämtliche Tests erfolgreich ausgeführt wurden.

Bei der Entwicklung gehen wir gemäss dem Test-Driven Development vor.
Das bedeuted, dass wir bei der Umsetzung eines Features oder beheben eines Fehlers folgende Schritte durchlaufen werden:

\begin{description}
  \item[Red]
    Ein Test für die noch fehlende Funktionalität wird erstellt.
    Dabei schlägt dieser Test noch fehl.
    Damit stellen wir sicher, dass der Test nicht auf etwas falsches prüft und er immer erfolgreich ist.
  \item[Green]
    Nun wird die Funktion auf eine einfache Art und Weise gelöst.
    Es muss noch nicht schöner Code sein, sonder der Test muss einfach erfolgreich durchlaufen können.
  \item[Refactor]
    Im letzten Schritt wird der geschriebene Code überarbeitet und verschönert.
    Erst danach kann dieser über einen Merge-Request in dem Git-Repository landen.
\end{description}

\subsubsection{Test-Coverage}

Wir werden die Test-Coverage laufend mit den Tests zusammen prüfen.
Unser Ziel ist es jeweils eine Coverage von 90\% zu erreichen.

Diese Angaben sind jedoch mit Vorsicht zu geniessen.
Eine Coverage von 100\% entspricht nicht einer kompletten Abdeckung aller möglichen Fälle.
Es werden alle Code-Stellen mindestens einmal durchschritten, nicht aber mit allen möglichen Inputs.

\end{document}
